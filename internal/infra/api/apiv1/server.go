package apiv1

import (
	"context"
	"telegram-ai-subscription/internal/domain"
	"telegram-ai-subscription/internal/domain/model"
	"telegram-ai-subscription/internal/usecase"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// Server holds dependencies for v1 API handlers.
// NOTE: Concrete implementations will be injected in later steps.
type Server struct {
	PricingUC usecase.PricingUseCase
	PlanUC    usecase.PlanUseCase
}

// NewServer constructs the API v1 server with its dependencies.
// In later steps, pass real implementations for PricingUC and PlanUC.
func NewServer(pricingUC usecase.PricingUseCase, planUC usecase.PlanUseCase) *Server {
	return &Server{
		PricingUC: pricingUC,
		PlanUC:    planUC,
	}
}

// Ensure our Server implements the generated strict interface.
var _ StrictServerInterface = (*Server)(nil)

// -----------------------------------------------------------------------------
// Router mount helper
// -----------------------------------------------------------------------------

// RegisterAPIV1 mounts the generated strict handler on the provided chi router.
// Call this from your main router composition:
//
//	import apiv1 "internal/infra/api/apiv1"
//	srv := apiv1.NewServer(/* deps in Step 3 */)
//	apiv1.RegisterAPIV1(r, srv)
func RegisterAPIV1(r chi.Router, srv *Server) {
	// No custom middlewares for now; you can add them later.
	h := NewStrictHandler(srv, nil) // generated by oapi-codegen
	HandlerFromMux(h, r)            // generated by oapi-codegen
}

// ---------------------- Helpers ----------------------

func jsonError(msg string) Error { return Error{Message: msg} }

func mapDomainErr(err error) (code int, payload Error) {
	switch err {
	case domain.ErrNotFound:
		return 404, jsonError("not found")
	case domain.ErrAlreadyExists:
		return 409, jsonError("already exists")
	case domain.ErrInvalidArgument:
		return 422, jsonError("invalid argument")
	default:
		return 400, jsonError(err.Error())
	}
}

// ---------------------- Models CRUD ----------------------

// ListModels: GET /api/v1/models
func (s *Server) ListModels(ctx context.Context, _ ListModelsRequestObject) (ListModelsResponseObject, error) {
	items, err := s.PricingUC.List(ctx)
	if err != nil {
		// Spec defines 400 (and 501), so fall back to 400 for errors.
		_, e := mapDomainErr(err)
		return ListModels400JSONResponse{BadRequestJSONResponse(e)}, nil
	}

	out := make([]Model, 0, len(items))
	for _, it := range items {
		out = append(out, toAPIModel(it))
	}
	return ListModels200JSONResponse{Items: &out}, nil
}

// CreateModel: POST /api/v1/models
func (s *Server) CreateModel(ctx context.Context, req CreateModelRequestObject) (CreateModelResponseObject, error) {
	body := req.Body
	if body == nil {
		return CreateModel400JSONResponse{BadRequestJSONResponse{Message: "missing body"}}, nil
	}
	created, err := s.PricingUC.Create(ctx, body.Name, body.InputPriceMicros, body.OutputPriceMicros, *body.Currency)
	if err != nil {
		code, e := mapDomainErr(err)
		switch code {
		case 409:
			return CreateModel409JSONResponse{ConflictJSONResponse(e)}, nil
		case 422:

			return CreateModel422JSONResponse{UnprocessableJSONResponse{Message: e.Message, Fields: nil}}, nil
		default:
			return CreateModel400JSONResponse{BadRequestJSONResponse(e)}, nil
		}
	}
	api := toAPIModel(created)
	// Depending on generator shape, you may need struct-literal instead:
	// return CreateModel201JSONResponse{Model: api}, nil  OR  {Body: api}
	return CreateModel201JSONResponse(api), nil
}

// GetModel: GET /api/v1/models/{name}
func (s *Server) GetModel(ctx context.Context, req GetModelRequestObject) (GetModelResponseObject, error) {
	got, err := s.PricingUC.Get(ctx, req.Name)
	if err != nil {
		code, e := mapDomainErr(err)
		if code == 404 {
			return GetModel404JSONResponse{NotFoundJSONResponse(e)}, nil
		}
		return GetModel400JSONResponse{BadRequestJSONResponse(e)}, nil
	}
	api := toAPIModel(got)
	return GetModel200JSONResponse(api), nil
}

// UpdateModel: PUT /api/v1/models/{name}
func (s *Server) UpdateModel(ctx context.Context, req UpdateModelRequestObject) (UpdateModelResponseObject, error) {
	body := req.Body
	if body == nil {
		return UpdateModel400JSONResponse{BadRequestJSONResponse{Message: "missing body"}}, nil
	}
	updated, err := s.PricingUC.Update(ctx, req.Name, body.InputPriceMicros, body.OutputPriceMicros, body.Currency)
	if err != nil {
		code, e := mapDomainErr(err)
		switch code {
		case 404:
			return UpdateModel404JSONResponse{NotFoundJSONResponse(e)}, nil
		case 422:
			return UpdateModel422JSONResponse{UnprocessableJSONResponse{Message: e.Message, Fields: nil}}, nil
		default:
			return UpdateModel400JSONResponse{BadRequestJSONResponse(e)}, nil
		}
	}
	api := toAPIModel(updated)
	return UpdateModel200JSONResponse(api), nil
}

// DeleteModel: DELETE /api/v1/models/{name}
func (s *Server) DeleteModel(ctx context.Context, req DeleteModelRequestObject) (DeleteModelResponseObject, error) {
	if err := s.PricingUC.Delete(ctx, req.Name); err != nil {
		code, e := mapDomainErr(err)
		switch code {
		case 404:
			return DeleteModel404JSONResponse{NotFoundJSONResponse(e)}, nil
		case 409:
			return DeleteModel409JSONResponse{ConflictJSONResponse(e)}, nil
		default:
			return DeleteModel400JSONResponse{BadRequestJSONResponse(e)}, nil
		}
	}
	return DeleteModel204Response{}, nil
}

// ---------------------- Activation Codes (Step 4C) ----------------------

// GenerateActivationCodes: POST /api/v1/activation-codes/generate
func (s *Server) GenerateActivationCodes(ctx context.Context, req GenerateActivationCodesRequestObject) (GenerateActivationCodesResponseObject, error) {
	body := req.Body
	if body == nil {
		return GenerateActivationCodes400JSONResponse{BadRequestJSONResponse{Message: "missing body"}}, nil
	}
	if s.PlanUC == nil {
		return GenerateActivationCodes501JSONResponse{
			NotImplementedJSONResponse: NotImplementedJSONResponse{Message: "not implemented"},
		}, nil
	}

	codes, err := s.PlanUC.GenerateActivationCodes(ctx, body.PlanId, int(body.Count))
	if err != nil {
		switch err {
		case domain.ErrPlanNotFound:
			return GenerateActivationCodes404JSONResponse{NotFoundJSONResponse{Message: "not found"}}, nil
		case domain.ErrInvalidArgument:
			return GenerateActivationCodes422JSONResponse{UnprocessableJSONResponse{Message: "invalid argument", Fields: nil}}, nil
		default:
			return GenerateActivationCodes400JSONResponse{BadRequestJSONResponse{Message: err.Error()}}, nil
		}
	}

	resp := ActivationCodeGenerateResponse{
		BatchId: uuid.New().String(),
	}
	if len(codes) > 0 {
		// Match the inline anonymous type generated for ActivationCodeGenerateResponse.codes
		items := make([]struct {
			Code      string     `json:"code"`
			ExpiresAt *time.Time `json:"expires_at,omitempty"`
		}, 0, len(codes))

		for _, c := range codes {
			items = append(items, struct {
				Code      string     `json:"code"`
				ExpiresAt *time.Time `json:"expires_at,omitempty"`
			}{
				Code:      c,
				ExpiresAt: nil, // your PlanUseCase doesnâ€™t emit expiries
			})
		}
		resp.Codes = items
	}
	return GenerateActivationCodes201JSONResponse(resp), nil
}

// toAPIModel maps the domain pricing row into the API shape with currency=IRR.
func toAPIModel(m *model.ModelPricing) Model {
	return Model{
		Name:              m.ModelName,
		InputPriceMicros:  m.InputTokenPriceMicros,
		OutputPriceMicros: m.OutputTokenPriceMicros,
		Currency:          "IRR",
		UpdatedAt:         m.UpdatedAt,
	}
}
